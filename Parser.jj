/* 
   Autor: Enrique González Gutiérrez
   Fecha: Enero 2026
*/

/*
 * La secuencia de comandos necesaria para obtener el ejecutable es:
 *     javacc Parser.jj 
 *     javac *.java 
 *     java -cp . test 
	   java CobolCompiler ejemplosP2y3_2C/eje0.cbl
 */

options {
  STATIC = false;
  IGNORE_CASE = true;
}

PARSER_BEGIN(CobolCompiler)
  import java.io.FileInputStream;
  import java.io.InputStream;

public class CobolCompiler {

		// Buffer para ir guardando el código de pila generado 
    StringBuilder outputBuffer = new StringBuilder();
	
		// Contador para etiquetas
		int labelCounter = 0;
		
		String newLabel() { 
      return "LBL" + (labelCounter++);
    }
	
	int tempCounter = 1; 
    java.util.Stack<String> pilaTemps = new java.util.Stack<String>();
	String newTemp() { return "t" + (tempCounter++); }
	
	void genera_linea(String linea, boolean conSangria) {
      if (conSangria) {
        outputBuffer.append("    " + linea + "\n"); 
      } else {
        outputBuffer.append(linea + "\n"); 
      }
    }
	
	 public static void main(String args[]) throws ParseException {
        CobolCompiler parser;
        InputStream input;
        try {
          if (args.length == 0) {
              input = System.in;
          } else {
              input = new FileInputStream(args[0]);
          }
          parser = new CobolCompiler(input);
          parser.Axioma(); 
		  
		  System.out.print(parser.outputBuffer.toString());
		   
        } catch (java.io.FileNotFoundException e) {
          System.err.println("error: archivo no encontrado");
        } catch (ParseException e) {
          System.err.println("error de sintaxis: " + e.getMessage());
        } catch (TokenMgrError e) {
          System.err.println("error lexico: " + e.getMessage());
        }
    }
  }
PARSER_END(CobolCompiler)

/* analizador lexico - lo que el parser debe de ignorar */

SKIP : 
{
  //  espacios y saltos de linea
    " " | "\t" | "\n" | "\r"
  //  comentario nº 1, *> hasta fin de linea
  | < "*>" (~["\n", "\r"])* >
  //  comentario nº2, asterisco en columna 7
  | < ("\n" | "\r" | "\r\n") "      *" (~["\n", "\r"])* >
}

/* TOKEN: Estas son válidas para nuestro lenguaje.
  Si no lo tenemos aquí o en SKIP dará error. */
  
	TOKEN : 
{
  // estructura del programa 
    < PROGRAMA: "PROGRAM" >
  | < INICIO: "BEGIN" >
  | < FIN: "END" >
  | < PUNTO: "." >
  | < COMA: "," >

  // verbos y asignación 
  | < MUEVE: "MOVE" >
  | < A: "TO" >
  | < SUMA: "ADD" >
  | < RESTA: "SUBTRACT" >
  | < DE: "FROM" >
  | < MULTIPLICA: "MULTIPLY" >
  | < POR: "BY" >
  | < DIVIDE: "DIVIDE" >
  | < LEE: "ACCEPT" >
  | < MUESTRA: "DISPLAY" >

  // condicionales y comparacion 
  | < SI: "IF" >
  | < ENTONCES: "THEN" >
  | < SINO: "ELSE" >
  | < ES: "IS" >
  | < NO: "NOT" >
  | < MAYOR: "GREATER" >
  | < MENOR: "LESS" >
  | < QUE: "THAN" >
  | < IGUAL: "EQUAL" >

  // bucles 
  | < MIENTRAS: "WHILE" >
  | < HACER: "DO" >
  | < VARYING: "VARYING" >
  
  
  // prueba
  | < DANDO: "GIVING" >
  | < ENTRE: "INTO" > // Por si usas DIVIDE A INTO B

  // operadores y paréntesis 
  | < MAS: "+" >
  | < MENOS: "-" >
  | < MULT: "*" >
  | < DIV: "/" >
  | < PA: "(" >
  | < PC: ")" >

  // datos
  | < ID: ["A"-"Z"] (["A"-"Z","0"-"9"])* ( "-" (["A"-"Z","0"-"9"])+ )* >
  | < NUM: (["0"-"9"])+ ( "." (["0"-"9"])+ )? ( ["e","E"] (["+","-"])? (["0"-"9"])+ )? >
  | < CAD: "\"" (~["\"","\n","\r"])* "\"" | "'" (~["'","\n","\r"])* "'" >
}

/* analizador sintactico */ 

// Primera regla
void Axioma() :
{}
{
  <PROGRAMA> <ID> <PUNTO>
  <INICIO>
  // { genera_linea("; - INFRAESTRUCTURA base  -", false); }
  Sentencias()
  <FIN> <PUNTO>
  <EOF>
}

// Distribuidor de verbos
void Sentencias() :
{}
{
  ( Sentencia() )+
}

// Distribuidor de verbos (singular) 
void Sentencia() :
{}
{
  (
      Io() 
    | Asignar()
    | Bucle()
    | Comparar()
  )
  
  // { genera_linea("; Detectada sentencia en: " + newLabel(), true); }
  
  <PUNTO>
}

//  Reglas auxiliares 

// Entrada/Salida
void Io() :
{ Token t; }
{
    <LEE> t = <ID> { genera_linea("lee " + t.image, true); }
  | <MUESTRA> ListaLiterales() 
}

// Un literal puede ser un identificador, un número o una cadena
void Literal() : { Token t; } {
    t = <ID> { genera_linea("print " + t.image, true); }
  | t = <NUM> { genera_linea("print " + t.image, true); }
  | t = <CAD> { genera_linea("print " + t.image, true); }
}


//  cuántos literales hay en la lista
int ListaLiterales() :
{ int n = 1; }
{
  Literal() 
  ( <COMA> Literal() { n++; } )* { return n; }
}
  
void Asignar() :
{ Token t_destino; String op1, op2, res, tempAsig; }
{
    // MOVE Expr TO ID -> VAR := temporal
    ( <MUEVE> Expr() <A> t_destino = <ID>
      { 
        res = pilaTemps.pop();
        /* [cite: 41]
        genera_linea("valori " + t_destino.image, true); 
        genera_linea("swap", true); 
        genera_linea("asigna", true); 
        */
        genera_linea(t_destino.image + " := " + res, true); 
      } 
    )
      
  | // ADD Expr TO ID -> t_new := ID + temporal; ID := t_new
    ( <SUMA> Expr() <A> t_destino = <ID>
      {
        op2 = pilaTemps.pop(); // Valor a sumar
        tempAsig = newTemp();
        genera_linea(tempAsig + " := " + t_destino.image + " + " + op2, true);
        genera_linea(t_destino.image + " := " + tempAsig, true); 
      } 
    )
        
  | // SUBTRACT Expr FROM ID -> t_new := ID - temporal; ID := t_new
    ( <RESTA> Expr() <DE> t_destino = <ID>
      {
        op2 = pilaTemps.pop(); // Valor a restar
        tempAsig = newTemp();
        genera_linea(tempAsig + " := " + t_destino.image + " - " + op2, true);
        genera_linea(t_destino.image + " := " + tempAsig, true); 
      } 
    )

  | // MULTIPLY Expr BY Expr GIVING ID -> t_new := op1 * op2; ID := t_new
    ( <MULTIPLICA> Expr() <POR> Expr() <DANDO> t_destino = <ID>
      { 
        op2 = pilaTemps.pop(); 
        op1 = pilaTemps.pop();
        tempAsig = newTemp();
        genera_linea(tempAsig + " := " + op1 + " * " + op2, true); 
        genera_linea(t_destino.image + " := " + tempAsig, true); 
      } 
    )

  | // DIVIDE Expr INTO Expr GIVING ID -> t_new := op1 / op2; ID := t_new
    ( <DIVIDE> Expr() <ENTRE> Expr() <DANDO> t_destino = <ID>
      { 
        op2 = pilaTemps.pop(); 
        op1 = pilaTemps.pop();
        tempAsig = newTemp();
        genera_linea(tempAsig + " := " + op1 + " / " + op2, true); 
        genera_linea(t_destino.image + " := " + tempAsig, true); 
      } 
    )
}

// jerarquia matematica

void Expr() : { String op1, op2, res; } {
  Mult() ( 
      <MAS> Mult() { 
          op2 = pilaTemps.pop(); op1 = pilaTemps.pop();
          res = newTemp();
          // genera_linea("add", true); <- comento la parte para para pila abstracta
          genera_linea(res + " := " + op1 + " + " + op2, true); 
          pilaTemps.push(res);
      } 
    | <MENOS> Mult() { 
          op2 = pilaTemps.pop(); op1 = pilaTemps.pop();
          res = newTemp();
          genera_linea(res + " := " + op1 + " - " + op2, true); 
          pilaTemps.push(res);
      } 
  )*
}

void Mult() : 
{ String op1, op2, res; } 
{
  Val() ( 
      <MULT> Val() 
      { 
          op2 = pilaTemps.pop(); // Segundo operando
          op1 = pilaTemps.pop(); // Primer operando
          res = newTemp();
          // genera_linea("mul", true); // <-- comento la parte para para pila abstracta
          genera_linea(res + " := " + op1 + " * " + op2, true); 
          pilaTemps.push(res); // Guardamos el temporal para la siguiente operación 
      } 
    | <DIV> Val() 
      { 
          op2 = pilaTemps.pop(); op1 = pilaTemps.pop();
          res = newTemp();
          // genera_linea("div", true); // <-- COMENTADO (Modelo Pila)
          genera_linea(res + " := " + op1 + " / " + op2, true); 
          pilaTemps.push(res); 
      } 
  )*
}

void Val() : { Token t; String res; } {
    t = <NUM> { 
      res = newTemp();
      // genera_linea("mete " + t.image, true); <- comento la parte para para pila abstracta
      genera_linea(res + " := " + t.image, true); 
      pilaTemps.push(res); 
    } 
  | t = <ID> { pilaTemps.push(t.image); }
  | <PA> Expr() <PC> 
}

// estructuras de control

// Estructura condicional IF-THEN-ELSE-END

void Comparar() :
{ String cond, lbl_else, lbl_fin = null; }
{
    <SI> cond = BooleanExpr() 
    {
        lbl_else = newLabel();
        // Invertimos la lógica para el salto al ELSE
        // Nota: Una forma simple es usar 'if not(cond) goto lbl_else'
        genera_linea("if " + cond + " goto " + newLabel() + " (falso) -> " + lbl_else, true); 
        // Pero para seguir exacto al prof:
        genera_linea("if_falso " + cond + " goto " + lbl_else, true);
    }
    <ENTONCES> Sentencias()
    ( 
        <SINO> 
        { 
            lbl_fin = newLabel(); 
            genera_linea("goto " + lbl_fin, true); 
            genera_linea(lbl_else + ":", false); 
        }
        Sentencias() 
    )?
    <FIN>
    {
        if (lbl_fin != null) genera_linea(lbl_fin + ":", false);
        else genera_linea(lbl_else + ":", false);
    }
}

// Bucle WHILE
void Bucle() :
{ String lbl_inicio, lbl_fin, cond; Token t_var; }
{
    ( // 1: WHILE TAC
      <MIENTRAS> 
      { 
        lbl_inicio = newLabel(); 
        lbl_fin = newLabel();
        genera_linea(lbl_inicio + ":", false); 
      }
      cond = BooleanExpr() 
      { genera_linea("if_falso " + cond + " goto " + lbl_fin, true); }
      <HACER> Sentencias() 
      <FIN>
      { 
        genera_linea("goto " + lbl_inicio, true); 
        genera_linea(lbl_fin + ":", false); 
      }
    )
  | ( // 2: VARYING TAC
      <VARYING> t_var = <ID> <DE> Expr() 
      {
        String valIni = pilaTemps.pop();
        genera_linea(t_var.image + " := " + valIni, true);
        lbl_inicio = newLabel();
        genera_linea(lbl_inicio + ":", false);
      }
      <A> Expr() 
      {
        String valLimit = pilaTemps.pop();
        lbl_fin = newLabel();
        // Comprobación de salida del bucle
        genera_linea("if " + t_var.image + " >= " + valLimit + " goto " + lbl_fin, true);
      }
      ( <POR> Expr() | { /* opcional */ } ) 
      <HACER> Sentencias() <FIN>
      {
        String incremento = "1";
        if (!pilaTemps.isEmpty()) incremento = pilaTemps.pop();
        
        String tNext = newTemp();
        genera_linea(tNext + " := " + t_var.image + " + " + incremento, true);
        genera_linea(t_var.image + " := " + tNext, true);
        genera_linea("goto " + lbl_inicio, true);
        genera_linea(lbl_fin + ":", false);
      }
    )
}

// Regla diagrama booleanExpr
String BooleanExpr() : 
{ String op1, op2, condicion = ""; Token t_no = null; Token t_op; }
{
  Expr() { op1 = pilaTemps.pop(); } 
  <ES> ( t_no = <NO> )? 
  ( 
      ( t_op = <MAYOR> | t_op = <MENOR> ) <QUE> Expr() 
      {
        op2 = pilaTemps.pop();
        String rel = (t_op.kind == MAYOR) ? ">" : "<";
        if (t_no != null) rel = (t_op.kind == MAYOR) ? "<=" : ">=";
        condicion = op1 + rel + op2;
      }
    | <IGUAL> <A> Expr() 
      { 
        op2 = pilaTemps.pop();
        String rel = (t_no != null) ? "!=" : "==";
        condicion = op1 + rel + op2;
      }
  ) 
  { return condicion; }
}