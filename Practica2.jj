/*
 * La secuencia de comandos necesaria para obtener el ejecutable es:
 *     javacc test1.jj 
 *     javac *.java 
 *     java -cp . test 
	   java practica2 ejemplosP2y3_2C/eje0.cbl
 */

options {
  STATIC = false;
  IGNORE_CASE = true;
}

PARSER_BEGIN(practica2)
  import java.io.FileInputStream;
  import java.io.InputStream;

public class practica2 {

		// Buffer para ir guardando el código de pila generado 
    StringBuilder outputBuffer = new StringBuilder();
	
		// Contador para etiquetas
		int labelCounter = 0;
		
		String newLabel() { 
      return "LBL" + (labelCounter++);
    }
	
	void genera_linea(String linea, boolean conSangria) {
      if (conSangria) {
        outputBuffer.append("    " + linea + "\n"); 
      } else {
        outputBuffer.append(linea + "\n"); 
      }
    }
	
	 public static void main(String args[]) throws ParseException {
        practica2 parser;
        InputStream input;
        try {
          if (args.length == 0) {
              input = System.in;
          } else {
              input = new FileInputStream(args[0]);
          }
          parser = new practica2(input);
          parser.Axioma(); 
		  
		  System.out.print(parser.outputBuffer.toString());
          System.out.println("Analisis realizado.");
		  
          System.out.println("analisis lexico completado con exito");
        } catch (java.io.FileNotFoundException e) {
          System.err.println("error: archivo no encontrado");
        } catch (ParseException e) {
          System.err.println("error de sintaxis: " + e.getMessage());
        } catch (TokenMgrError e) {
          System.err.println("error lexico: " + e.getMessage());
        }
    }
  }
PARSER_END(practica2)

/* analizador lexico - lo que el parser debe de ignorar */

SKIP : 
{
  //  espacios y saltos de linea
    " " | "\t" | "\n" | "\r"
  //  comentario nº 1, *> hasta fin de linea
  | < "*>" (~["\n", "\r"])* >
  //  comentario nº2, asterisco en columna 7
  | < ("\n" | "\r" | "\r\n") "      *" (~["\n", "\r"])* >
}

/* TOKEN: Estas son válidas para nuestro lenguaje.
  Si no lo tenemos aquí o en SKIP dará error. */
  
	TOKEN : 
{
  // estructura del programa 
    < PROGRAMA: "PROGRAM" >
  | < INICIO: "BEGIN" >
  | < FIN: "END" >
  | < PUNTO: "." >
  | < COMA: "," >

  // verbos y asignación 
  | < MUEVE: "MOVE" >
  | < A: "TO" >
  | < SUMA: "ADD" >
  | < RESTA: "SUBTRACT" >
  | < DE: "FROM" >
  | < MULTIPLICA: "MULTIPLY" >
  | < POR: "BY" >
  | < DIVIDE: "DIVIDE" >
  | < LEE: "ACCEPT" >
  | < MUESTRA: "DISPLAY" >

  // condicionales y comparacion 
  | < SI: "IF" >
  | < ENTONCES: "THEN" >
  | < SINO: "ELSE" >
  | < ES: "IS" >
  | < NO: "NOT" >
  | < MAYOR: "GREATER" >
  | < MENOR: "LESS" >
  | < QUE: "THAN" >
  | < IGUAL: "EQUAL" >

  // bucles 
  | < MIENTRAS: "WHILE" >
  | < HACER: "DO" >
  | < VARYING: "VARYING" >

  // operadores y paréntesis 
  | < MAS: "+" >
  | < MENOS: "-" >
  | < MULT: "*" >
  | < DIV: "/" >
  | < PA: "(" >
  | < PC: ")" >

  // datos
  | < ID: ["A"-"Z"] (["A"-"Z","0"-"9"])* ( "-" (["A"-"Z","0"-"9"])+ )* >
  | < NUM: (["0"-"9"])+ ( "." (["0"-"9"])+ )? ( ["e","E"] (["+","-"])? (["0"-"9"])+ )? >
  | < CAD: "\"" (~["\"","\n","\r"])* "\"" | "'" (~["'","\n","\r"])* "'" >
}

/* analizador sintactico */ 

// Primera regla
void Axioma() :
{}
{
  <PROGRAMA> <ID> <PUNTO>
  <INICIO>
  // { genera_linea("; - INFRAESTRUCTURA base  -", false); }
  Sentencias()
  <FIN> <PUNTO>
  <EOF>
}

// Distribuidor de verbos
void Sentencias() :
{}
{
  ( Sentencia() )+
}

// Distribuidor de verbos (singular) 
void Sentencia() :
{}
{
  (
      Io() 
    | Asignar()
    | Bucle()
    | Comparar()
  )
  
  // { genera_linea("; Detectada sentencia en: " + newLabel(), true); }
  
  <PUNTO>
}

//  Reglas auxiliares 

// Entrada/Salida
void Io() :
{ Token t; int n; }
{
    <LEE> t = <ID>
      { genera_linea("lee " + t.image, true); }
  | <MUESTRA> 
      n = ListaLiterales() // LLama a la regla que cuenta literales
      { genera_linea("print " + n, true); }
}


//  cuántos literales hay en la lista
int ListaLiterales() :
{ int n = 1; }
{
  Literal() 
  ( <COMA> Literal() { n++; } )* { return n; }
}


// Un literal puede ser un identificador, un número o una cadena
void Literal() :
{ Token t; }
{
    t = <ID> 
      { genera_linea("valord " + t.image, true); }
  | t = <NUM> 
      { genera_linea("mete " + t.image, true); }
  | t = <CAD>
      { genera_linea("metecad " + t.image, true); }
}

void Asignar() : {} { 
  (<MUEVE> | <SUMA> | <RESTA> | <MULTIPLICA> | <DIVIDE>) 
  ( <ID> | <NUM> | <PA> | <PC> | <MAS> | <MENOS> | <MULT> | <DIV> | <A> | <DE> | <POR> )* }

void Bucle() : {} { 
  (<VARYING> | <MIENTRAS>) 
  ( <ID> | <NUM> | <A> | <DE> | <POR> | <HACER> | <ES> | <NO> | <MAYOR> | <MENOR> | <QUE> | <IGUAL> )* Sentencias() <FIN> 
}

void Comparar() : {} { 
  <SI> 
  ( <ID> | <NUM> | <ES> | <NO> | <MAYOR> | <MENOR> | <QUE> | <IGUAL> | <A> )* <ENTONCES> Sentencias() ( <SINO> Sentencias() )? <FIN> 
}